/* signal.c - signal related functions */

#include "signal.h"

extern PCB * ProcessPCBs[MAX_PROCESSES+1]; //reference the process pcbs from elsewhere (process.c)

extern volatile int current_process; //integer representing the currently executing process

extern uint32_t ProcessPhysAddr[MAX_PROCESSES+1];

//Local functions
// static void kill_task(int proc_id);
// static void ignore_signal(void);
void * default_handler(uint32_t signum);
void handle_signal(int signum, int proc_id);

/*
 * set_handler
 *   DESCRIPTION: Sets the handler for a signal.
 *   INPUTS: signum -- the signal number.
 *           handler_address -- the handler to associate with the signal.
 *   OUTPUTS: none.
 *   RETURN VALUE: 0 on success, -1 on failure.
 *   SIDE EFFECTS: sets a signal handler.
 */
int32_t set_handler(int32_t signum, void* handler_address) {
	int caller_process = current_process;
	
	//check signum amd handler address
	if (signum < 0 || signum > NUM_SIGS)
		return -1;
	else if (handler_address == NULL) {
		ProcessPCBs [caller_process]->handler[signum] = default_handler(signum);
		return -1;
	}
	
	ProcessPCBs[caller_process]->handler[signum] = default_handler(signum);
	
	return 0;
}


/*
 * sigreturn
 *   DESCRIPTION: Returns from a signal.
 *   INPUTS: none.
 *   OUTPUTS: none.
 *   RETURN VALUE: Returns the hardware context value of EAX to avoid special casing
 *   SIDE EFFECTS: copies hardware context.
 */
int32_t sigreturn(void) {
	// TODO
	
	//Return the hardware context value of eax
	return ProcessPCBs[current_process]->eax;
}

void signals_init(){
	int i, j;
	for (i = 0; i <= MAX_PROCESSES; i++) {
		for (j=0; j < NUM_SIGS; j++) {
			ProcessPCBs[i]->pending[j] = 0; //No signals pending
			ProcessPCBs[i]->masked[j] = 0; //All signals UN-masked
			ProcessPCBs[i]->handler[j] = default_handler(j); //All sighandlers default
		}
	}
}
		
void * default_handler(uint32_t signum) {
	if ( signum == 0 || signum == 1 || signum == 2 )
		return (void *) KILL_TASK;
	else if ( signum == 3 || signum == 4 )
		return (void *) IGNORE_SIG;
	else {
		printf("ERROR: Invalid signum %d", signum);
		return (void *) -1;
	}
}

void send_signal(int signum, int proc_id) {

	//Check to see if this signal is masked
	if ( ProcessPCBs[proc_id]->masked[signum] )
		return;
	
	printf("sending SIG%d to proc %d\n", signum, proc_id);
	
	//This signal is now pending for this process
	ProcessPCBs[proc_id]->pending[signum] = 1; 
}

//Checks for pending signals for the specified process
//and handles them
void handle_current_pending_signals () { //BREAK
	int i;
	
	if(ProcessPCBs[current_process]->cs == KERNEL_CS)
		return;
	
	for (i=0; i < NUM_SIGS; i++)
		if ( ProcessPCBs[current_process]->pending[i] )
			handle_signal (i, current_process);
}

//Checks for pending signals for the specified process
//and handles them
void handle_pending_signals (int proc_id) { //BREAK
	int i;
	
	if(ProcessPCBs[proc_id]->cs == KERNEL_CS)
		return;
	
	for (i=0; i < NUM_SIGS; i++)
		if ( ProcessPCBs[proc_id]->pending[i] )
			handle_signal (i, proc_id);
}
	
void handle_signal(int signum, int proc_id) {
	int i;
	
	cli(); //Just in case
	//BREAK

	//Mask all other signals
	for (i=0; i < NUM_SIGS; i++) {
		if (i != signum )
			ProcessPCBs[proc_id]->masked[i] = 1;
	}
	
	//Signal is no longer pending
	ProcessPCBs[proc_id]->pending[signum] = 0; 

	if (ProcessPCBs[proc_id]->handler[signum] == (void*) KILL_TASK)
		halt_proc(proc_id, 256);
	else if (ProcessPCBs[proc_id]->handler[signum] == (void*) IGNORE_SIG)
		return;
	
	
	map_process_page(ProcessPhysAddr[proc_id]); 
	
	// Set up signal handler's stack frame
	// - push asm code for exectuing sigreturn
	// - push processes hardware context 
	// - push signum to user stack
	// - push retaddr to user stack
	// Execute (in user space) the handler 
	// Call sigreturn (user program will do this automatically if retaddr is setup correctly
	asm volatile( 
	"movl %[user_esp], %%ebx				\n" 
	
	//Set up return linkage
	"movl sigreturn_asm_linkage, %%eax		\n"
	"movl (%%eax), %%eax					\n"
	"movl %%eax, (%%ebx)					\n"
	"subl $4, %%ebx							\n"

	"movl 4(%%eax), %%eax	\n"
	"movl %%eax, (%%ebx)					\n"
	"subl $4, %%ebx							\n"
	
	"sigreturn_asm_linkage: 				\n"
	"movl $10, %%eax						\n"
	"int $0x80								\n"
	
	// - push processes hardware context 
	//TODO
	
	// - push signum to user stack
	//TODO
	
	// - push retaddr to user stack
	//TODO
	
	// Execute (in user space) the handler
	//TODO
	
	:	//outputs
	
	: 	//inputs
		[user_esp] "g" (ProcessPCBs[proc_id]->esp)
	
	: 	//clobber list
		"%eax", 
		"%ebx"
	);	
}
