#define ASM     1

#define P2PCBADDR 0x7FC000

# These are assembly wrappers for interrupt handlers. 
# Most of them just push all relevant registers, call the C handler function (with arguments if needed), 
# restore all the regesters, and then return from interrupt.
# The others store register values to the PCB and then continue, as they might casuse a process switch.

# NOTE: RTC may no longer cause a process switch, we might be able to get rid of the PCB saves for it...

.text

.globl	kbd_interrupt
.globl 	irq2_interrupt
.globl	rtc_interrupt
.globl	pit_interrupt
.globl	mouse_interrupt
.globl	unkwn_interrupt
.globl  syscallwrapper
.globl	current_processs
.globl	handle_pending_signals

.align 4

pit_interrupt:
# save the interrupted processe's state, in case this interrupt will cause a process switch
	movl	%eax, temp_storageEAX_pit	#save these register values, as they will be overwritten by the next operations
	movl	%edi, temp_storageEDI_pit
	
	movl	%esp, %edi				#move esp to edi for bitmasking operation
									#bitmask with current esp to move up to the pcb location for the current process
									#for this trick to work, it is imperitive that the stack start at the bottom of each processes' 8kB kernel chunk
									#and the PCB be located at the top of that kernel chunk.
	andl	$0xFFFFE000 , %edi		#set destination register to the memory location of the current process PCB
	

	movl	%eax, 0(%edi) 			# save EAX	
	movl	%ebx, 4(%edi)			# save EBX
	movl	%ecx, 8(%edi)			# save ECX
	movl	%edx, 12(%edi)			# save EDX
	movl	%ebp, 16(%edi)			# save EBP
	movl	%esi, 28(%edi)			# save ESI
	movw	%ds, 40(%edi)			# save current data seg
	
	movl	8(%esp), %eax			# extract old eflags
	movl	%eax, 48(%edi)			# save old eflags
	movl	4(%esp), %eax			# extract old CS from stack (pushed during interrupt)
	movw	%ax, 42(%edi)			# save old CS
	movl	(%esp), %eax			# extract old EIP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 24(%edi)			# save EIP
	cmpw	$0x10, 42(%edi)			# check to see if we're supposed to return to kernel or user space
	je		int_from_kernel_pit		# if we were interrupted in kernel code, don't try and extract a new esp/ss from the stack
	jmp		int_from_user_pit
	
	int_from_user_pit:
	movl	12(%esp), %eax			# extract old ESP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 20(%edi)			# save ESP
	movl	16(%esp), %eax			# extract old SS from stack. This was pushed by the processor during the HW interrupt call
	movw	%ax, 44(%edi)			# save SS
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$20,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this pit interrupt never happened
	jmp continue_pit_int

	int_from_kernel_pit:
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$12,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this pit interrupt never happened
	jmp continue_pit_int

	continue_pit_int:
									# however, we still need to save EDI into the PCB struct. 
	movl	temp_storageEDI_rtc, %eax	# move the old EDI value to EAX
	movl	%eax, 32(%edi)			# save EDI
									# There's probably a more elegant way of doing this, I just can't think of it

	movl	temp_storageEAX_pit, %eax	# restore registers
	movl	temp_storageEDI_pit, %edi

	call pit_handler #call the handler function
	
	movl	%edi, temp_storageEDI_pit
	movl	%esp, %edi				#move esp to edi for bitmasking operation
	andl	$0xFFE000 , %edi		#set destination register to the memory location of the current process PCB
	
	movl 4(%edi), %ebx				#restore interrupted process's registers from the PCB
	movl 8(%edi), %ecx
	movl 12(%edi), %edx
	movl 28(%edi), %esi
	movl 16(%edi), %ebp
	movl 0(%edi), %eax
	movw 40(%edi), %ds
	
	movl temp_storageEDI_pit, %edi
	iret #//BREAK
	

kbd_interrupt:
	# save the interrupted processe's state, in case this interrupt will cause a process switch
	movl	%eax, temp_storageEAX_kbd	#save these register values, as they will be overwritten by the next operations
	movl	%edi, temp_storageEDI_kbd
	
	movl	%esp, %edi				#move esp to edi for bitmasking operation
									#bitmask with current esp to move up to the pcb location for the current process
									#for this trick to work, it is imperitive that the stack start at the bottom of each processes' 8kB kernel chunk
									#and the PCB be located at the top of that kernel chunk.
	andl	$0xFFFFE000 , %edi		#set destination register to the memory location of the current process PCB
	

	movl	%eax, 0(%edi) 			# save EAX	
	movl	%ebx, 4(%edi)			# save EBX
	movl	%ecx, 8(%edi)			# save ECX
	movl	%edx, 12(%edi)			# save EDX
	movl	%ebp, 16(%edi)			# save EBP
	movl	%esi, 28(%edi)			# save ESI
	movw	%ds, 40(%edi)			# save current data seg
	
	movl	8(%esp), %eax			# extract old eflags
	movl	%eax, 48(%edi)			# save old eflags
	movl	4(%esp), %eax			# extract old CS from stack (pushed during interrupt)
	movw	%ax, 42(%edi)			# save old CS
	movl	(%esp), %eax			# extract old EIP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 24(%edi)			# save EIP
	cmpw	$0x10, 42(%edi)			# check to see if we're supposed to return to kernel or user space
	je		int_from_kernel_kbd		# if we were interrupted in kernel code, don't try and extract a new esp/ss from the stack
	jmp		int_from_user_kbd
	
	int_from_user_kbd:
	movl	12(%esp), %eax			# extract old ESP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 20(%edi)			# save ESP
	movl	16(%esp), %eax			# extract old SS from stack. This was pushed by the processor during the HW interrupt call
	movw	%ax, 44(%edi)			# save SS
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$20,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_kbd_int

	int_from_kernel_kbd:
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$12,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_kbd_int

	continue_kbd_int:
									# however, we still need to save EDI into the PCB struct. 
	movl	temp_storageEDI_rtc, %eax	# move the old EDI value to EAX
	movl	%eax, 32(%edi)			# save EDI
									# There's probably a more elegant way of doing this, I just can't think of it

	movl	temp_storageEAX_kbd, %eax	# restore registers
	movl	temp_storageEDI_kbd, %edi

	call kbd_handler #call the handler function
	
	movl	%edi, temp_storageEDI_kbd
	movl	%esp, %edi				#move esp to edi for bitmasking operation
	andl	$0xFFE000 , %edi		#set destination register to the memory location of the current process PCB
	
	movl 4(%edi), %ebx				#restore interrupted process's registers from the PCB
	movl 8(%edi), %ecx
	movl 12(%edi), %edx
	movl 28(%edi), %esi
	movl 16(%edi), %ebp
	movl 0(%edi), %eax
	movw 40(%edi), %ds
	
	movl temp_storageEDI_kbd, %edi
	iret #//BREAK
	
irq2_interrupt:
	pushl %es
	pushl %ds
	pushl %eax
	pushl %ebp
	pushl %edi
	pushl %esi
	pushl %edx
	pushl %ecx
	pushl %ebx
	
	call irq2_handler
	
	popl %ebx
	popl %ecx
	popl %edx
	popl %esi
	popl %edi
	popl %ebp
	popl %eax
	popl %ds
	popl %es
	iret #//BREAK
	
	
mouse_interrupt:

	# save the interrupted processe's state, in case this interrupt will cause a process switch
	movl	%eax, temp_storageEAX_mouse	#save these register values, as they will be overwritten by the next operations
	movl	%edi, temp_storageEDI_mouse
	
	movl	%esp, %edi				#move esp to edi for bitmasking operation
									#bitmask with current esp to move up to the pcb location for the current process
									#for this trick to work, it is imperitive that the stack start at the bottom of each processes' 8kB kernel chunk
									#and the PCB be located at the top of that kernel chunk.
	andl	$0xFFFFE000 , %edi		#set destination register to the memory location of the current process PCB
	

	movl	%eax, 0(%edi) 			# save EAX	
	movl	%ebx, 4(%edi)			# save EBX
	movl	%ecx, 8(%edi)			# save ECX
	movl	%edx, 12(%edi)			# save EDX
	movl	%ebp, 16(%edi)			# save EBP
	movl	%esi, 28(%edi)			# save ESI
	movw	%ds, 40(%edi)			# save current data seg
	
	movl	8(%esp), %eax			# extract old eflags
	movl	%eax, 48(%edi)			# save old eflags
	movl	4(%esp), %eax			# extract old CS from stack (pushed during interrupt)
	movw	%ax, 42(%edi)			# save old CS
	movl	(%esp), %eax			# extract old EIP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 24(%edi)			# save EIP
	cmpw	$0x10, 42(%edi)			# check to see if we're supposed to return to kernel or user space
	je		int_from_kernel_mouse			# if we were interrupted in kernel code, don't try and extract a new esp/ss from the stack
	jmp		int_from_user_mouse
	
	int_from_user_mouse:
	movl	12(%esp), %eax			# extract old ESP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 20(%edi)			# save ESP
	movl	16(%esp), %eax			# extract old SS from stack. This was pushed by the processor during the HW interrupt call
	movw	%ax, 44(%edi)			# save SS
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$20,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_mouse_int

	int_from_kernel_mouse:
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$12,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_mouse_int

	continue_mouse_int:
									# however, we still need to save EDI into the PCB struct. 
	movl	temp_storageEDI_mouse, %eax	# move the old EDI value to EAX
	movl	%eax, 32(%edi)			# save EDI
									# There's probably a more elegant way of doing this, I just can't think of it

	movl	temp_storageEAX_mouse, %eax	# restore registers
	movl	temp_storageEDI_mouse, %edi
	
	
	
	call mouse_handler #call the handler function
	
	movl	%edi, temp_storageEDI_mouse
	movl	%esp, %edi				#move esp to edi for bitmasking operation
	andl	$0xFFE000 , %edi		#set destination register to the memory location of the current process PCB
	
	movl 4(%edi), %ebx				#restore interrupted process's registers from the PCB
	movl 8(%edi), %ecx
	movl 12(%edi), %edx
	movl 28(%edi), %esi
	movl 16(%edi), %ebp
	movl 0(%edi), %eax
	movw 40(%edi), %ds

	
	movl temp_storageEDI_mouse, %edi
	iret

	
rtc_interrupt:

	# save the interrupted processe's state, in case this interrupt will cause a process switch
	movl	%eax, temp_storageEAX_rtc	#save these register values, as they will be overwritten by the next operations
	movl	%edi, temp_storageEDI_rtc
	
	movl	%esp, %edi				#move esp to edi for bitmasking operation
									#bitmask with current esp to move up to the pcb location for the current process
									#for this trick to work, it is imperitive that the stack start at the bottom of each processes' 8kB kernel chunk
									#and the PCB be located at the top of that kernel chunk.
	andl	$0xFFFFE000 , %edi		#set destination register to the memory location of the current process PCB
	

	movl	%eax, 0(%edi) 			# save EAX	
	movl	%ebx, 4(%edi)			# save EBX
	movl	%ecx, 8(%edi)			# save ECX
	movl	%edx, 12(%edi)			# save EDX
	movl	%ebp, 16(%edi)			# save EBP
	movl	%esi, 28(%edi)			# save ESI
	movw	%ds, 40(%edi)			# save current data seg
	
	movl	8(%esp), %eax			# extract old eflags
	movl	%eax, 48(%edi)			# save old eflags
	movl	4(%esp), %eax			# extract old CS from stack (pushed during interrupt)
	movw	%ax, 42(%edi)			# save old CS
	movl	(%esp), %eax			# extract old EIP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 24(%edi)			# save EIP
	cmpw	$0x10, 42(%edi)			# check to see if we're supposed to return to kernel or user space
	je		int_from_kernel_rtc			# if we were interrupted in kernel code, don't try and extract a new esp/ss from the stack
	jmp		int_from_user_rtc
	
	int_from_user_rtc:
	movl	12(%esp), %eax			# extract old ESP from stack. This was pushed by the processor during the HW interrupt call
	movl	%eax, 20(%edi)			# save ESP
	movl	16(%esp), %eax			# extract old SS from stack. This was pushed by the processor during the HW interrupt call
	movw	%ax, 44(%edi)			# save SS
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$20,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_rtc_int

	int_from_kernel_rtc:
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$12,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the current process like this kbd interrupt never happened
	jmp continue_rtc_int

	continue_rtc_int:
									# however, we still need to save EDI into the PCB struct. 
	movl	temp_storageEDI_rtc, %eax	# move the old EDI value to EAX
	movl	%eax, 32(%edi)			# save EDI
									# There's probably a more elegant way of doing this, I just can't think of it

	movl	temp_storageEAX_rtc, %eax	# restore registers
	movl	temp_storageEDI_rtc, %edi
	
	
	
	call rtc_handler #call the handler function
	
	movl	%edi, temp_storageEDI_rtc
	movl	%esp, %edi				#move esp to edi for bitmasking operation
	andl	$0xFFE000 , %edi		#set destination register to the memory location of the current process PCB
	
	movl 4(%edi), %ebx				#restore interrupted process's registers from the PCB
	movl 8(%edi), %ecx
	movl 12(%edi), %edx
	movl 28(%edi), %esi
	movl 16(%edi), %ebp
	movl 0(%edi), %eax
	movw 40(%edi), %ds

	
	movl temp_storageEDI_rtc, %edi
	iret #//BREAK

	


	
	
unkwn_interrupt:
	pushl %es
	pushl %ds
	pushl %eax
	pushl %ebp
	pushl %edi
	pushl %esi
	pushl %edx
	pushl %ecx
	pushl %ebx
	
	call unkinthandler
	
	popl %ebx
	popl %ecx
	popl %edx
	popl %esi
	popl %edi
	popl %ebp
	popl %eax
	popl %ds
	popl %es
	iret #//BREAK


# undeclared labels are automatically assumed external
syscall_table:
	.long 0x00 #dummy - system calls are 1-indexed, not zero-indexed
	.long halt
	.long execute
	.long read
	.long write
	.long open
	.long close
	.long getargs
	.long vidmap
	.long set_handler
	.long sigreturn
	.long change_colors
num_syscalls = (. - syscall_table) / 4

temp_storageEAX_kbd:
	.long 0
temp_storageEDI_kbd:
	.long 0
	
temp_storageEAX_rtc:
	.long 0
temp_storageEDI_rtc:
	.long 0
	
temp_storageEAX_mouse:
	.long 0
temp_storageEDI_mouse:
	.long 0
	
temp_storageEAX_pit:
	.long 0
temp_storageEDI_pit:
	.long 0
	
temp_storageEAX_syscall:
	.long 0
temp_storageEDI_syscall:
	.long 0
	
	
syscallwrapper:
	# perform error checking on the system call number.
	# just return if it's weird
	cmpl	$num_syscalls, %eax
	jae		syscallwrapper_done
	cmpl	$0x00, %eax
	je		syscallwrapper_done
	
	# check if this is an execute function. 
	# save registers to the PCB first if this is so.
	# see definition of the PCB struct in process.c for the order and offsets used here.
	# THIS CODE MIGHT HAVE TO BE CHANGED IF THE PCB STRUCT DEFINITION IS EDITED
	cmpl	$0x02, %eax
	jne		continue
	movl	%eax, temp_storageEAX_syscall	#save these register values, as they will be overwritten by the next operations
	movl	%edi, temp_storageEDI_syscall
	
	movl	%esp, %edi				#move esp to edi for bitmasking operation
									#bitmask with current esp to move up to the pcb location for the current process
									#for this trick to work, it is imperitive that the stack start at the bottom of each processes' 8kB kernel chunk
									#and the PCB be located at the top of that kernel chunk.
	andl	$0xFFE000 , %edi		#set destination register to the memory location of the current process PCB
	
	movl	%eax, 0(%edi) 			# save EAX	
	movl	%ebx, 4(%edi)			# save EBX
	movl	%ecx, 8(%edi)			# save ECX
	movl	%edx, 12(%edi)			# save EDX
	movl	%ebp, 16(%edi)			# save EBP
	movl	12(%esp), %eax			# extract old ESP from stack. This was pushed by the processor during the int0x80 call
	movl	%eax, 20(%edi)			# save ESP
	movl	(%esp), %eax			# extract old EIP from stack. This was pushed by the processor during the int0x80 call
	movl	%eax, 24(%edi)			# save EIP
	
	#ADDED BY AJ
	#MAKE SURE THE PCB STRUCT IS CHANGED!!!!
	movl	8(%esp), %eax			# extract old EFLAGS from stack. This was pushed by the processor during the int0x80 call	
	movl	%eax, 48(%edi)			# save EFLAGS
	
	movl	%esi, 28(%edi)			# save ESI
	movw	%ds, 40(%edi)			# save current data seg -- these three might not be needed???
	movw	%cs, 42(%edi)			# save current code seg
	movw	%ss, 44(%edi)			# save current stack seg
	
	movl	%esp, %eax				# save kernel stack pointer for restoring
	addl	$-5,  %eax				# in the saved argument, throw out the 5 arguments pushed by the int0x80 call
	movl	%eax, 36(%edi)			# now, when halt restores this value, it will look to the callee like execute never happened
	
									# however, we still need to save EDI into the PCB struct. 
	movl	temp_storageEDI_syscall, %eax	# move the old EDI value to EAX
	movl	%eax, 32(%edi)			# save EDI
									# There's probably a more elegant way of doing this, I just can't think of it

	movl	temp_storageEAX_syscall, %eax	# restore registers
	movl	temp_storageEDI_syscall, %edi
	
	continue:
	# don't save eax, as it will contain a return value
	pushl	%es
	pushl	%ds
	pushl	%ebp
	pushl	%edi
	pushl	%esi
	pushl	%ecx
	pushl	%edx
	pushl	%ebx
	
	pushl	%edx		# push three arguments from system call
	pushl	%ecx
	pushl	%ebx
	
	call	*syscall_table(, %eax, 4)
	# Return value now sits in EAX
	addl	$12, %esp	# discard arguments from stack
	
	call handle_current_pending_signals
	
	popl	%ebx
	popl	%edx
	popl	%ecx
	popl	%esi
	popl	%edi
	popl	%ebp
	popl	%ds
	popl	%es
	
syscallwrapper_done:
	iret #//BREAK

